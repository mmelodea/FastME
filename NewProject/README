::::::::::::::::::: FastME :::::::::::::::::::::
 Probing and Discriminating Data by MC Topology
::::::::::::::::::::::::::::::::::::::::::::::::

Use Instructions:

1. You need to format your ntuples to get a matrix with the ordered objects (electron, muon, jets, met ...) and properties (pT, eta and phi):
 
 1.1. The matrix must be tri-dimensional (matrix[number_final_state][objects][properties]):
  1.1.1. The first indice indicates the object order;
  1.1.2. The second indice indicates the properties order;
  1.1.3. The third indice indicates the propertie and its resolution order;
  
 Example- For the 4l (full leptonic case):
     Data[0][2][0] points to some lepton phi value;
     While, Data[0][2][1] points to lepton phi resolution value;
     
2. To run the analysis I recommend to use the interface code (runFME.C). The code there makes the full connection with
   the Fast Matrix Element librares. The compilation was originaly processed on ROOT (I recommend to use it because the its libraries
   included in the FastME libraries). To use that code (there is a example file there):
   
   2.1. Write a txt file with data, sig, bkg ntuples path, the TTree name and the Branch name corresponding to matrix.
   This file must be passed as an argument to the function contained in the interfacing code;
   2.2. In ROOT command line make the argument function compile command, pointing to the code at "Interface/";
   2.3. After compilation, use the function instantiated to call FastME;
   
   Simplify Steps:  root [0].L runFME.C+
		    root [1]runFME("inputs")
   **(!!Do not forget to put "#fim" at the end of txt file!!)
		    
3. The results of the analysis will be stored in a ROOT file containing a Tree with quantities like minDR_ToSig/Bkg (minimum data-sig/bkg distances found),
   the P_SB discriminant value (indicating how much sig/bkg the data look like), the fraction (%) of event inputs like sig/bkg, and the event
   weight (there are 3 weight defined: one given by sig, one given by bkg and one given by the relation between the two).
   **(For details about that weight take a look at FME_Module/FastME.cxx)

4. At "interface/inputs" can be seen the way to pass the informations to FastME processing. Currently there is one final state completely implemented
   in which 4 models can be called to organize Data and MC matrix components to make the comparation. More two final states (4l+2j and lv+2j) are been concluded (look at "Developing/").
   The models are (generally):
   4.1. DR_Order_Res: organize matrix components by distance and constraining same ressonance for two related components;
   4.2. DR_Order_noRes: the same first idea above, but without ressonance constraint;
   4.3. PT_Order_Res: organize matrix components by transverse momentum value (from higher to smaller);
   4.4. PT_Order_noRes: the same idea above, but without use ressonance constraint.
   **(Will be still implemented to lv+2j the models jet distance and pT ordering)
